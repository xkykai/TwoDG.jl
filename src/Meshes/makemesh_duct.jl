using TwoDG

"""
tfi_duct map a unit square mesh to a cos^2 duct
mesh = mkmesh_duct(mesh,db,dt,H)
   mesh:     mesh structure generated by mkamesh_square
              flag = 0 (diagonals sw - ne) (default)
              flag = 1 (diagonals nw - se)
   db:       height of bottom bump
   dt:       height of top bump
   H:        height of channel
"""
function mkmesh_duct(mesh, db, dt, H)
    # Set curved flags
    mesh.fcurved .= true
    mesh.tcurved .= true
    
    # Transform mesh.p
    transform_points!(mesh.p, mesh.p, db, dt, H)
    
    # Transform mesh.dgnodes
    n_points = size(mesh.dgnodes, 1)
    n_elements = size(mesh.t, 1)
    
    # Permute and reshape for processing
    dg_permuted = permutedims(mesh.dgnodes, (1, 3, 2))
    p_dg = reshape(dg_permuted, (:, 2))
    pnew_dg = similar(p_dg)
    
    # Apply transformation
    transform_points!(pnew_dg, p_dg, db, dt, H)
    
    # Reshape and permute back
    dg_reshaped = reshape(pnew_dg, (n_points, n_elements, 2))
    dgnodes = permutedims(dg_reshaped, (1, 3, 2))

    mesh.dgnodes .= dgnodes
    
    return cgmesh(mesh) 
end

"""
    transform_points!(pnew, p, db, dt, H)

Helper function to transform points according to the duct mapping.
"""
function transform_points!(pnew, p, db, dt, H)
    # Scale x coordinates
    pnew[:,1] = 3.0 .* p[:,1]
    
    # Process each point individually
    @inbounds for i in 1:size(p, 1)
        x = pnew[i, 1]
        y = p[i, 2]
        
        if x <= 1.0 || x >= 2.0
            # Outside the bump region
            pnew[i, 2] = H * y
        else
            # Inside the bump region
            sin_term = sin(Ï€ * (x - 1.0))^2
            pnew[i, 2] = y * (H - dt * sin_term) + (1.0 - y) * (db * sin_term)
        end
    end
    
    return pnew
end